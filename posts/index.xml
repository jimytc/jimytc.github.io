<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Jim Chen</title><link>https://jimytc.com/posts/</link><description>Recent content in Posts on Jim Chen</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 30 Aug 2021 10:02:30 +0800</lastBuildDate><atom:link href="https://jimytc.com/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Specify Rails Version When Init</title><link>https://jimytc.com/posts/2021/08/30/qnote_on_specify_rails_version_when_init/</link><pubDate>Mon, 30 Aug 2021 10:02:30 +0800</pubDate><guid>https://jimytc.com/posts/2021/08/30/qnote_on_specify_rails_version_when_init/</guid><description>It&amp;rsquo;s common to installed multiple versions of the same gem. For example, rails with 5.2.7 and 6.1.1, etc. By default, it uses the latest release.
To specify the old one, just use command like below, which specifies the expected version with underscode _.</description></item><item><title>Typescript Array.map 後的型別推論技巧 - type predicate</title><link>https://jimytc.com/posts/2021/03/27/qnote_on_using_type_predicates/</link><pubDate>Sat, 27 Mar 2021 08:40:22 +0800</pubDate><guid>https://jimytc.com/posts/2021/03/27/qnote_on_using_type_predicates/</guid><description>在集合或陣列類型的資料處理中，偶爾會遇到需要使用 Array.map 把所需要的資料從物件中轉化成另一個陣列物件。 例如
class Foo { bar?: number constructor(bar?: number) { this.bar = bar; } } let foos: Foo[]; fooArray = [ new Foo(123), new Foo() ]; let bars = foos.</description></item><item><title>TypeScript 上手二三事</title><link>https://jimytc.com/posts/2021/02/05/qnote_on_adapting_typescript/</link><pubDate>Fri, 05 Feb 2021 16:06:10 +0800</pubDate><guid>https://jimytc.com/posts/2021/02/05/qnote_on_adapting_typescript/</guid><description>經歷過 Java, Ruby, JavaScript(咦?)，最近因為職涯的轉換開始上手 TypeScript。 簡單說 TypeScript 就是 JavaScript 的超集，最大的好處是加強了型別系統。 上手的過程使用了 91 (Joey Chen) 極速開發帶領的 Tennis Kata 練習。
明確的主題可以練習，不會漫無目的的從頭開始學。 新的語言有新的工具鍊，必須要有基本使用的能力。 承 2，我希望可以最快速的達到我在 Ruby 環境的純 coding 戰力。 目前的感受
用了一個主題上手真的比較精準和快速，簡單說就是作中學。 多了編譯的過程貌似會慢一點點（ TypeScript -&amp;gt; JavaScript -&amp;gt; run Test）。 內建型別推論（Type Inference）在多數情形下可以不去註記型別。 承 3，但是對於某些特別用途，例如 dictionary，就必須要記得註記他。 因為 3 跟 4，反而在寫程式的時候需要特別去思考要不要作型別註記，覺得會有一點額外耗腦。</description></item><item><title>Have Custom Attribute for a Rails ActiveRecord Model</title><link>https://jimytc.com/posts/2020/08/03/note_rails_active_records_attribute/</link><pubDate>Mon, 03 Aug 2020 17:00:19 +0800</pubDate><guid>https://jimytc.com/posts/2020/08/03/note_rails_active_records_attribute/</guid><description>Framework is pretty opinionated in its area, but that also means it handles many repetitive and tedious tasks. When using ORM like ActiveRecord, it saved us so much time defining which model has what attributes.</description></item><item><title>Generate RSA key pairs with encryption</title><link>https://jimytc.com/posts/2020/05/20/qnote_generate_rsa_keys_and_x509_cert/</link><pubDate>Wed, 20 May 2020 23:00:49 +0800</pubDate><guid>https://jimytc.com/posts/2020/05/20/qnote_generate_rsa_keys_and_x509_cert/</guid><description>I&amp;rsquo;ve spent some time investigating how to create RSA key pairs for a feature.
Put a note here just in case I need it again.
Generate RSA private key with 2048 bits $ openssl genrsa -out private.</description></item><item><title>在 Ruby 的測試中輕鬆做到參數化測試</title><link>https://jimytc.com/posts/2020/04/21/simple_parameterized_test_in_ruby/</link><pubDate>Tue, 21 Apr 2020 10:10:48 +0800</pubDate><guid>https://jimytc.com/posts/2020/04/21/simple_parameterized_test_in_ruby/</guid><description>只是個小短篇記錄最近的反思和實際測試能力的應用。
上下文（Context） 最近的兩份工作都主要是在 Rails 開發，兩份工作都是高度重視測試的團隊，不過在實際的場景不太相同一樣，前一份工作主要已經引入或者開發了改善開發效率的工具，而後者是已經有一定許多既存的測試，也有一定複雜度的架構，不過許多開發工具都還在比較早期的階段，比較沒有著墨過多在開發流程的部分。
遇到的問題 參數化測試是撰寫測試案例中非常好用的一種技巧，通常的使用情境在於測試的對象和步驟是一致的，但是輸入和輸出是不同的。
舉例來說，我們有一個類別如下。
class OpGreater attr_reader :op1, :op2 def initialize(op1, op2) @op1 = op1 @op2 = op2 end def call op1 &amp;gt; op2 end end 測試案例可以如下</description></item><item><title>[閱讀心得] OKR：做最重要的事</title><link>https://jimytc.com/posts/2020/02/29/reading_notes_measure_what_matters/</link><pubDate>Sat, 29 Feb 2020 22:24:13 +0800</pubDate><guid>https://jimytc.com/posts/2020/02/29/reading_notes_measure_what_matters/</guid><description>上一份工作中因緣際會必須負責一個小團隊，加上自己時不時會閱讀一下商管的文章或書籍，對於管理的知識一直都有在學習。知道這本「OKR：做最重要的事」其實是兩年前的事情，去年公司也在實務上正式導入，也因次順著把這本書給唸了一次，多了解它一點也比較能知道引領者原本的設定，比較不會偏離 Andrew Grove 以及 John Doerr 的理論和實踐。
而即便有倖存者偏差的可能，這套方法也還是有不錯的參考價值，帶來管理方法裡不同的思考方向和實踐。
它是一種目標管理方法 OKR 是 Objective, Key Results 的縮寫，中文翻譯是－目標及關鍵結果。它是一套近年來流行的目標管理架構，與我們比較耳熟的 KPI（Key Performance Indicator）同屬目標管理的範疇；但是 OKR 對於目標的設定、驗證和執行是不同的。這篇心得沒有要細部探討兩者的不同，除了書面資料，我也沒辦法給出比較確切的差異，然後我相信大家看了還是會一頭霧水，因為我當初看的時候也是⋯更不用說還有什麼 MBO 之類的了。
既然都是目標管理，那到底有什麼不同？
首先我覺得是賦權。傳統的經營管理中，目標一般是由上往下佈達，在執行端的人基本上只有接受決策和執行命令。在 OKR 的架構中則是鼓勵組織中公開討論和分享以及訂定各自現在以及未來的目標；不管這個目標是來自某一個同功能的團隊內部（內部需求，由下往上），或者是在組織末端分屬不同功能團隊的成員一致想達成的（橫向整合需求，由下往上），或是公司管理階層想要達成的目標（由上往下）；然而不管是哪一種，被選擇的 OKR 都是公開透明的，即使是公司最高負責人的個人 OKR 也是。其背後的想法在於透明化組織前進的方向，來讓群體盡力在同一個方向上努力，已達到最大的效果。</description></item><item><title>[閱讀筆記] 單元測試的藝術 Part II</title><link>https://jimytc.com/posts/2020/02/23/reading_notes_unit_testing_part_two/</link><pubDate>Sun, 23 Feb 2020 23:58:40 +0800</pubDate><guid>https://jimytc.com/posts/2020/02/23/reading_notes_unit_testing_part_two/</guid><description>單元測試的藝術 - 核心技術篇 (Ch3 - Ch6) 回顧 工作單元的可見最終結果有三。
有回傳值。 系統可見的狀態或行為改變。 呼叫不受測試控制的第三方系統。 測試的種類
單元測試 整合測試 (New) 互動測試 互動測試－ 針對物件如何向其他物件發送訊息的測試。用於測試工作單元的最終結果是與其他系統互動的時候，例如，發送 Log。
測試的藝術在於 在合適的地方加入或使用一個中介層封裝原本的呼叫行為，藉此可以模擬中介層行為進而測試工作單元。 測試程式面臨的挑戰 受測單元的外部依賴（External Dependency） 無法控制的外部依賴會造成“抑制測試”的現象。</description></item><item><title>[閱讀筆記] 單元測試的藝術 Part I</title><link>https://jimytc.com/posts/2020/02/23/reading_notes_unit_testing_part_one/</link><pubDate>Sun, 23 Feb 2020 23:58:24 +0800</pubDate><guid>https://jimytc.com/posts/2020/02/23/reading_notes_unit_testing_part_one/</guid><description>單元測試的藝術 - 入門篇 (Ch1 &amp;amp; Ch2) 定義們 被測試系統 SUT（System Under Test） 被測試程式所測試的對象，可以是函數，可以是類別，可以是一個複雜的元件，也可以是一個軟體。 一般來說
工作單元、使用案例 Use Case 從呼叫系統的一個公開方法，到產生一個測試可見最終結果，在期間這個系統所發生的行為統稱為一個工作單元。
可見的最終結果可以是
回傳值（如果公開方法有回傳值的話） 系統可見的狀態或行為改變，不需要查詢私有狀態就能取得。 呼叫一個不受測試所控制的第三方系統，這個第三方系統不回傳任何值或者回傳值不被系統使用。 單元測試 Unit Test 一個單元測試是一段自動化的程式碼，這段程式會呼叫被測試的工作單元，之後對這個單元的最終結果的某些假設或期望進行驗證。</description></item><item><title>Trapped by Ruby Operators Precedence</title><link>https://jimytc.com/posts/2020/02/22/trapped_by_ruby_operators_precedence/</link><pubDate>Sat, 22 Feb 2020 21:50:00 +0800</pubDate><guid>https://jimytc.com/posts/2020/02/22/trapped_by_ruby_operators_precedence/</guid><description>Let the story begin I started to work on a new production code repository, and I could tell my productivity degraded for almost 7 workdays. But this was not because of my lack of domain knowledge in the new production code nor the new development environment and configuration.</description></item><item><title>使用 GitHub Action 部署部落格 (Hugo)</title><link>https://jimytc.com/posts/2020/02/16/setup_with_github_action/</link><pubDate>Sun, 16 Feb 2020 15:48:03 +0800</pubDate><guid>https://jimytc.com/posts/2020/02/16/setup_with_github_action/</guid><description>這篇想稍微紀錄一下自己改採 GitHub Action 部署的過程，會想使用 GitHub 這個新功能，一部分是想知道有什麼東西之後可以利用的，另外一個讓自己更懶惰一點。哈哈。
什麼是 GitHub Action Github Action 簡單說起來就是 GitHub 自家推出的 CI/CD 工具，好處是跟放在 GitHub 上面的 Repository 有更好的整合，也可以更集中管理，有好有壞，但至少多了一個選擇。
設定的方式可以參考官方文件，基本上需要加入一個 .github/workflows/&amp;lt;workflow_name&amp;gt;.yml，然後在裡面定義不同的工作和工作內部的步驟，詳細設定就自己參考官方文件吧。
GitHub Action 有一個特色是開發人員可以開發 Action 並發布給大家使用，目前已經可以找到很多人已經做好的 Action 來使用，像是發布訊息到 Slack，寄信之類的，非常多。當然，這次要使用的 Hugo 編譯和 GitHub Page 部署也有人做好了。下面就快速帶過我的設定吧</description></item><item><title>Review and... Go</title><link>https://jimytc.com/posts/2020/02/11/review_and_go/</link><pubDate>Tue, 11 Feb 2020 12:09:28 +0800</pubDate><guid>https://jimytc.com/posts/2020/02/11/review_and_go/</guid><description>都已經是 2020 的二月了，現在才來回顧及展望好像也太晚了，不過嘛，總是會有許多事情跳出來讓人忙東忙西。2019 下半年開始，生命中發生了許多轉折，一直到這兩天也才有空好好整理那隨意丟放的置物櫃，放胡思亂想的那種。
2019, 自我認識和探尋的一年 再次定位 自認是個興趣廣泛、好奇且願意嘗試的人，像是買了 Roli Keyboard 和 Ableton，緩步的嘗試學習音樂製作。或是嘗試了兩個月的子彈筆記術，試圖讓自己更加聚焦。也一直廣泛吸收和應用企管和軟體管理相關的知識。然而這幾年廣泛地點技能，總是有種自己在原地打轉的感覺。直到 2019 報名了 熱血點火師 91 的測試驅動開發及持續重構課程後，看到堅持在一條路上的人綻放的光芒，才確定自己的主線角色應該是在工程上，專注在一條線上，才能借力強化其它支線。主線不明的故事，是不會吸睛的，更何況我也不是賣顏值的，哈哈。
整裝 清楚自己的目標，張開地圖，大概就知道路線長什麼樣了，也就會定期的檢查，是不是該轉彎了。比較大的記錄點應該是兩年前幫自己設定的目標都做到了吧——團隊中的好夥伴 Maso 跟我說想往資料科學的方向發展很久了，一直以來在各種不同的工作中想辦法尋求平衡，終於在去年順利的讓他專心了！混混亂亂的團隊流程也總算是在去年整理過一輪了（感謝 Russ）。挖掘了幾位有潛力的夥伴（小珍妮、Ron 以及 Leslie），很高興曾經一起努力，也相信大家都找到自己綻放光芒的舞台，而最珍惜最開心的就是對我的那份信任（還有願意被我推坑 XD）。
新的篇章 到了這個年歲才比較掌握到自己應該多放點心在怎麼做，而不是做什麼，畢竟即便目標眾多，但也都是很清楚明瞭。2020年二月，我轉換到另一個團隊讓自己能夠更加專心的在我要走的路，而且客觀條件上，這個機會都更能夠滿足我對未來生活的想像。
離開原本的團隊也是很不捨，特別是對幾個被我推坑很深的夥伴，希望我挖的坑不會害你們爬不出來啊！話說回來，這是我人生中的一個新篇章，卻不是我們友誼故事的結束，未來保持連絡囉。
2020 專業、影響力、自信 2020年一月在商業思維學院的線下實作課程中完成了今年的目標設定，老實說，那個目標絕對是挑戰自己極限的，這樣也好，總是要跨出舒適圈。 希望 2021 年的時候回顧，我可以很肯定地說，我可以幫自己打上 專業、影響力、自信 這三個標籤，同時，在個人發展上，成為一個 有影響力的後端軟體工程師。</description></item><item><title>Podcasts I subscribed</title><link>https://jimytc.com/posts/2020/01/26/podcasts_i_subscribed/</link><pubDate>Sun, 26 Jan 2020 21:43:46 +0800</pubDate><guid>https://jimytc.com/posts/2020/01/26/podcasts_i_subscribed/</guid><description>My friends and I happened to have a conversation about subscribed podcasts for communication, collaboration and engineering. We shared some with each other and I think it&amp;rsquo;s worth writing a post about them.</description></item><item><title>Test Cases Like How We Speak</title><link>https://jimytc.com/posts/2019/08/06/test_cases_like_how_we_speak/</link><pubDate>Tue, 06 Aug 2019 09:12:13 +0800</pubDate><guid>https://jimytc.com/posts/2019/08/06/test_cases_like_how_we_speak/</guid><description>In my current software development work, we&amp;rsquo;ve talked about TDD within the team but we haven&amp;rsquo;t really apply this process for couple reasons. But we do care about the products we shipped.</description></item><item><title>Rust Lang at a Glance</title><link>https://jimytc.com/posts/2019/05/28/rust-lang-at-a-glance/</link><pubDate>Tue, 28 May 2019 23:47:44 +0800</pubDate><guid>https://jimytc.com/posts/2019/05/28/rust-lang-at-a-glance/</guid><description>Just a quick glance at Rust-lang, haven’t really done things with it. But I’m interested in its memory management system, so called “ownership”, and no “null” design.
Rust, borned in 2006, was firstly a personal project but then sponsored by Mozilla since 2009.</description></item><item><title>You but Not Only You</title><link>https://jimytc.com/posts/2019/05/20/you-but-not-only-you/</link><pubDate>Mon, 20 May 2019 23:54:49 +0800</pubDate><guid>https://jimytc.com/posts/2019/05/20/you-but-not-only-you/</guid><description>RailsConf 2019, as a technical conference, there is a bunch of presentations about the fundamentals, deep inside the Rails framework, leveling up the skills. Rather than deep diving into those talks I attended, I would like to share more about DHH and other speakers’ thoughts about the Rails community, the connections within it and the bonds with the world.</description></item><item><title>Httplog, the Useful Tool for Rubyist to Debug Http Request</title><link>https://jimytc.com/posts/2018/08/13/httplog-the-useful-tool-for-rubyist-to-debug-http-request/</link><pubDate>Mon, 13 Aug 2018 15:13:58 +0800</pubDate><guid>https://jimytc.com/posts/2018/08/13/httplog-the-useful-tool-for-rubyist-to-debug-http-request/</guid><description>Our application introduced “Sharing to Twitter” feature and we did our own integration with Twitter API. We maintained the integration by ourselves because we did not want to introduce too many dependencies.</description></item><item><title>As a Porter Among Tables in Postgresql</title><link>https://jimytc.com/posts/2016/03/25/as-a-porter-among-tables-in-postgresql/</link><pubDate>Fri, 25 Mar 2016 16:00:00 +0800</pubDate><guid>https://jimytc.com/posts/2016/03/25/as-a-porter-among-tables-in-postgresql/</guid><description>Imagine we have two tables, creations and creation_metadata. id of creations table is foreign key of creation_metadata table. They should be one-to-one relation but actually, records in creations table might not have a corresponding row in creation_metadata table.</description></item><item><title>Ruby Http Request</title><link>https://jimytc.com/posts/2015/08/05/ruby-http-request/</link><pubDate>Wed, 05 Aug 2015 09:33:11 +0800</pubDate><guid>https://jimytc.com/posts/2015/08/05/ruby-http-request/</guid><description>During trial on sending GET request to AppFigures’ RESTful API, I started with net/http and add my client key to request hash.
When firing the request, I have some more request params to use.</description></item></channel></rss>